<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>üìä BTCUSDT Chart</title>
    <script src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: #1a1a1a;
        color: #ffffff;
        overflow: hidden;
      }

      .header {
        background: #2d2d2d;
        padding: 15px 20px;
        border-bottom: 1px solid #404040;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 15px;
      }

      .header h1 {
        font-size: 1.5rem;
        color: #ffffff;
        margin: 0;
      }

      .controls {
        display: flex;
        gap: 20px;
        align-items: center;
        flex-wrap: wrap;
      }

      .control-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .control-group label {
        font-weight: 600;
        color: #cccccc;
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .button-group {
        display: flex;
        gap: 4px;
        background: #3a3a3a;
        border-radius: 6px;
        padding: 2px;
      }

      .btn {
        padding: 8px 12px;
        border: none;
        background: transparent;
        color: #cccccc;
        cursor: pointer;
        border-radius: 4px;
        font-size: 0.85rem;
        font-weight: 500;
        transition: all 0.2s ease;
        min-width: 45px;
      }

      .btn:hover {
        background: #4a4a4a;
        color: #ffffff;
      }

      .btn.active {
        background: #1976d2;
        color: #ffffff;
        box-shadow: 0 2px 4px rgba(25, 118, 210, 0.3);
      }

      .chart-container {
        height: calc(100vh - 80px);
        position: relative;
        background: #1a1a1a;
        display: flex;
        flex-direction: column;
      }

      #candlestick-chart {
        flex: 2;
        min-height: 300px;
      }

      #rsi-chart {
        flex: 1;
        min-height: 150px;
        border-top: 1px solid #404040;
        display: none;
      }

      #chart {
        width: 100%;
        height: 100%;
      }

      .loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(26, 26, 26, 0.9);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        transition: opacity 0.3s ease;
      }

      .loading-overlay.hidden {
        opacity: 0;
        pointer-events: none;
      }

      .loading-spinner {
        width: 40px;
        height: 40px;
        border: 3px solid #404040;
        border-top: 3px solid #1976d2;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 15px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .loading-text {
        color: #cccccc;
        font-size: 1rem;
        margin-bottom: 8px;
      }

      .loading-subtext {
        color: #888888;
        font-size: 0.85rem;
      }

      .status-indicator {
        position: absolute;
        top: 15px;
        right: 15px;
        display: flex;
        align-items: center;
        gap: 8px;
        background: rgba(45, 45, 45, 0.9);
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 0.8rem;
        z-index: 100;
      }

      .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #4caf50;
        animation: pulse 2s infinite;
      }

      .status-dot.disconnected {
        background: #f44336;
        animation: none;
      }

      @keyframes pulse {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
        100% {
          opacity: 1;
        }
      }

      @media (max-width: 768px) {
        .header {
          flex-direction: column;
          gap: 10px;
        }

        .controls {
          flex-direction: column;
          gap: 15px;
          width: 100%;
        }

        .control-group {
          width: 100%;
        }

        .button-group {
          justify-content: center;
        }
      }
    </style>
  </head>
  <body>
    <div class="header">
      <h1>üìä BTCUSDT Chart</h1>
      <div class="controls">
        <div class="control-group">
          <label>‚è∞ Timeframe</label>
          <div class="button-group" id="timeframe-buttons">
            <button class="btn" data-timeframe="1m">1m</button>
            <button class="btn" data-timeframe="5m">5m</button>
            <button class="btn" data-timeframe="1h">1h</button>
            <button class="btn active" data-timeframe="1d">1d</button>
          </div>
        </div>
        <div class="control-group">
          <label>üìà Indicators</label>
          <div class="button-group" id="indicator-buttons">
            <button class="btn active" data-indicator="none">None</button>
            <button class="btn" data-indicator="sma5">SMA(5)</button>
            <button class="btn" data-indicator="ema20">EMA(20)</button>
            <button class="btn" data-indicator="both">MA Both</button>
            <button class="btn" data-indicator="rsi">RSI</button>
            <button class="btn" data-indicator="stochastic">Stochastic</button>
            <button class="btn" data-indicator="stochrsi">StochRSI</button>
            <button class="btn" data-indicator="macd">MACD</button>
            <button class="btn" data-indicator="bollinger">Bollinger</button>
            <button class="btn" data-indicator="psar">PSAR</button>
            <button class="btn" data-indicator="all">All</button>
          </div>
        </div>
      </div>
    </div>

    <div class="chart-container">
      <div id="candlestick-chart"></div>
      <div id="rsi-chart"></div>

      <div class="loading-overlay" id="loading-overlay">
        <div class="loading-spinner"></div>
        <div class="loading-text" id="loading-text">Loading chart data...</div>
        <div class="loading-subtext" id="loading-subtext">
          Initializing connection
        </div>
      </div>

      <div class="status-indicator" id="status-indicator">
        <div class="status-dot" id="status-dot"></div>
        <span id="status-text">Connecting...</span>
      </div>
    </div>

    <script>
      class CryptoChart {
        constructor() {
          this.candlestickChart = null;
          this.rsiChart = null;
          this.candleSeries = null;
          this.smaSeries = null;
          this.emaSeries = null;
          this.rsiSeries = null;
          this.rsiOverboughtLine = null;
          this.rsiOversoldLine = null;
          this.lastPriceLine = null; // TradingView-style last price line
          this.websocket = null;

          // Current state
          this.currentTimeframe = "1d";
          this.currentIndicator = "none";
          this.isLoading = false;
          this.rawData = null;
          this.candleData = [];
          this.reconnectAttempts = 0;
          this.maxReconnectAttempts = 5;
          this.lastPrice = null;

          // Initialize
          this.initializeCharts();
          this.bindEvents();
          this.loadInitialData();
        }

        initializeCharts() {
          // Candlestick chart
          const candlestickContainer =
            document.getElementById("candlestick-chart");
          this.candlestickChart = LightweightCharts.createChart(
            candlestickContainer,
            {
              width: candlestickContainer.offsetWidth,
              height: candlestickContainer.offsetHeight,
              layout: {
                background: { color: "#1a1a1a" },
                textColor: "#ffffff",
              },
              grid: {
                vertLines: { color: "#2a2a2a" },
                horzLines: { color: "#2a2a2a" },
              },
              crosshair: {
                mode: LightweightCharts.CrosshairMode.Normal,
              },
              rightPriceScale: {
                borderColor: "#485158",
                textColor: "#ffffff",
              },
              timeScale: {
                borderColor: "#485158",
                textColor: "#ffffff",
                timeVisible: true,
                secondsVisible: false,
              },
              localization: {
                timeFormatter: (time) => {
                  return new Date(time * 1000).toLocaleString("id-ID", {
                    timeZone: "Asia/Jakarta",
                    day: "2-digit",
                    month: "2-digit",
                    year: "numeric",
                    hour: "2-digit",
                    minute: "2-digit",
                  });
                },
              },
            }
          );

          // RSI chart
          const rsiContainer = document.getElementById("rsi-chart");
          this.rsiChart = LightweightCharts.createChart(rsiContainer, {
            width: rsiContainer.offsetWidth,
            height: rsiContainer.offsetHeight,
            layout: {
              background: { color: "#1a1a1a" },
              textColor: "#ffffff",
            },
            grid: {
              vertLines: { color: "#2a2a2a" },
              horzLines: { color: "#2a2a2a" },
            },
            rightPriceScale: {
              borderColor: "#485158",
              textColor: "#ffffff",
              scaleMargins: { top: 0.1, bottom: 0.1 },
            },
            timeScale: {
              borderColor: "#485158",
              textColor: "#ffffff",
              timeVisible: true,
              secondsVisible: false,
            },
            localization: {
              timeFormatter: (time) => {
                return new Date(time * 1000).toLocaleString("id-ID", {
                  timeZone: "Asia/Jakarta",
                  day: "2-digit",
                  month: "2-digit",
                  year: "numeric",
                  hour: "2-digit",
                  minute: "2-digit",
                });
              },
            },
          });

          // Candlestick series
          this.candleSeries = this.candlestickChart.addCandlestickSeries({
            upColor: "#26a69a",
            downColor: "#ef5350",
            borderVisible: false,
            wickUpColor: "#26a69a",
            wickDownColor: "#ef5350",
          });

          // Initialize last price line (TradingView-style)
          this.lastPriceLine = this.candlestickChart.addLineSeries({
            color: "#f7931a", // Bitcoin orange
            lineWidth: 2,
            lineStyle: LightweightCharts.LineStyle.Solid,
            crosshairMarkerVisible: false,
            priceLineVisible: true,
            lastValueVisible: true,
            priceFormat: {
              type: "price",
              precision: 2,
              minMove: 0.01,
            },
          });

          // Handle window resize
          window.addEventListener("resize", () => {
            this.candlestickChart.applyOptions({
              width: candlestickContainer.offsetWidth,
              height: candlestickContainer.offsetHeight,
            });
            this.rsiChart.applyOptions({
              width: rsiContainer.offsetWidth,
              height: rsiContainer.offsetHeight,
            });
          });
        }

        bindEvents() {
          // Timeframe buttons
          document
            .getElementById("timeframe-buttons")
            .addEventListener("click", (e) => {
              if (e.target.classList.contains("btn")) {
                const timeframe = e.target.dataset.timeframe;
                if (timeframe !== this.currentTimeframe) {
                  this.setActiveButton("timeframe-buttons", e.target);
                  this.currentTimeframe = timeframe;
                  this.loadDataForTimeframe();
                }
              }
            });

          // Indicator buttons
          document
            .getElementById("indicator-buttons")
            .addEventListener("click", (e) => {
              if (e.target.classList.contains("btn")) {
                const indicator = e.target.dataset.indicator;
                if (indicator !== this.currentIndicator) {
                  this.setActiveButton("indicator-buttons", e.target);
                  this.currentIndicator = indicator;
                  this.updateIndicators();
                }
              }
            });
        }

        setActiveButton(groupId, activeButton) {
          const group = document.getElementById(groupId);
          group
            .querySelectorAll(".btn")
            .forEach((btn) => btn.classList.remove("active"));
          activeButton.classList.add("active");
        }

        async loadInitialData() {
          await this.loadDataForTimeframe();
        }

        async loadDataForTimeframe() {
          if (this.isLoading) return;

          this.isLoading = true;
          this.showLoading(
            `Loading ${this.currentTimeframe} data...`,
            "Fetching candles from server"
          );

          // Close existing websocket
          this.closeWebSocket();

          try {
            const response = await fetch(
              `/api/candles?timeframe=${this.currentTimeframe}`
            );

            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();

            if (!data.success) {
              throw new Error(data.message || "Failed to load data");
            }

            this.processData(data);
            this.hideLoading();
            this.connectWebSocket();
          } catch (error) {
            console.error("Error loading data:", error);
            this.showError(`Failed to load data: ${error.message}`);
          } finally {
            this.isLoading = false;
          }
        }

        processData(data) {
          if (!data.candles || !Array.isArray(data.candles)) {
            throw new Error("Invalid data format");
          }

          // Store global info
          this.globalLastTime = data.globalLastTime;
          this.globalLastTimeJakarta = data.globalLastTimeJakarta;
          this.globalLastPrice = data.globalLastPrice;

          // Convert data to format expected by Lightweight Charts (UNIX seconds)
          const allCandles = data.candles
            .filter(
              (candle) =>
                candle.time &&
                candle.open &&
                candle.high &&
                candle.low &&
                candle.close
            )
            .map((candle) => ({
              time: Number(candle.time), // Use UNIX seconds directly
              open: parseFloat(candle.open),
              high: parseFloat(candle.high),
              low: parseFloat(candle.low),
              close: parseFloat(candle.close),
            }))
            .sort((a, b) => a.time - b.time);

          // For timeframes other than 1d, load only recent data for performance
          let candleData;
          if (this.currentTimeframe === "1d") {
            // Full historical data for daily
            candleData = allCandles;
          } else {
            // Last 1000 candles for intraday
            candleData = allCandles.slice(-1000);
          }

          this.candleData = candleData;
          this.rawData = data;

          // Set last price from latest candle
          if (candleData.length > 0) {
            this.lastPrice =
              this.globalLastPrice || candleData[candleData.length - 1].close;
          }

          // Debug log
          if (candleData.length > 0) {
            const lastCandle = candleData[candleData.length - 1];
            const jakartaTime = new Date(lastCandle.time * 1000).toLocaleString(
              "id-ID",
              {
                timeZone: "Asia/Jakarta",
                day: "2-digit",
                month: "2-digit",
                year: "numeric",
                hour: "2-digit",
                minute: "2-digit",
              }
            );

            console.log(`üìä Frontend - Last loaded candle:`, {
              time: lastCandle.time,
              close: lastCandle.close,
              jakartaTime: jakartaTime,
              globalLastPrice: this.globalLastPrice,
              lastPrice: this.lastPrice,
            });
          }

          // Set data to chart
          this.candleSeries.setData(candleData);

          // Update last price line
          this.updateLastPriceLine();

          // Apply zoom strategy based on timeframe
          this.applyZoomStrategy();

          // Update indicators
          this.updateIndicators();

          console.log(
            `üìä Loaded ${candleData.length} candles for ${this.currentTimeframe}`
          );
        }

        // TradingView-style last price line
        updateLastPriceLine() {
          if (!this.lastPrice || !this.candleData.length) return;

          // Create a horizontal line at the last price
          const lastTime = this.candleData[this.candleData.length - 1].time;
          const lineData = [{ time: lastTime, value: this.lastPrice }];

          this.lastPriceLine.setData(lineData);

          // Update the price line options to show current price
          this.lastPriceLine.applyOptions({
            priceLineVisible: true,
            lastValueVisible: true,
            title: `Last: $${this.lastPrice.toFixed(2)}`,
          });
        }

        applyZoomStrategy() {
          // Strategy based on timeframe for optimal viewing
          switch (this.currentTimeframe) {
            case "1m":
              // For 1m, show last 100 candles and scroll to real-time
              this.candlestickChart.timeScale().setVisibleLogicalRange({
                from: Math.max(0, this.candleData.length - 100),
                to: this.candleData.length - 1,
              });
              setTimeout(() => {
                this.candlestickChart.timeScale().scrollToRealTime();
              }, 100);
              break;

            case "5m":
              // For 5m, show last 200 candles
              this.candlestickChart.timeScale().setVisibleLogicalRange({
                from: Math.max(0, this.candleData.length - 200),
                to: this.candleData.length - 1,
              });
              setTimeout(() => {
                this.candlestickChart.timeScale().scrollToRealTime();
              }, 100);
              break;

            case "1h":
              // For 1h, show last 168 candles (about 1 week)
              this.candlestickChart.timeScale().setVisibleLogicalRange({
                from: Math.max(0, this.candleData.length - 168),
                to: this.candleData.length - 1,
              });
              break;

            case "1d":
            default:
              // For 1d, fit all content initially, then scroll to recent
              this.candlestickChart.timeScale().fitContent();
              setTimeout(() => {
                // Show last 365 days (1 year) for daily
                this.candlestickChart.timeScale().setVisibleLogicalRange({
                  from: Math.max(0, this.candleData.length - 365),
                  to: this.candleData.length - 1,
                });
              }, 200);
              break;
          }

          // Sync RSI chart timeScale if visible
          if (this.rsiChart && this.isRSIVisible()) {
            // Match the main chart's visible range
            setTimeout(() => {
              const visibleRange = this.candlestickChart
                .timeScale()
                .getVisibleLogicalRange();
              if (visibleRange) {
                this.rsiChart.timeScale().setVisibleLogicalRange(visibleRange);
              }
            }, 300);
          }
        }

        updateIndicators() {
          // Remove existing indicator series
          this.clearIndicators();

          // Hide/Show RSI chart based on indicator selection
          this.toggleRSIChart();

          if (!this.rawData || !this.candleData) return;

          const indicators = this.rawData.indicators || {};

          // Add SMA(5) if requested
          if (
            ["sma5", "both", "all"].includes(this.currentIndicator) &&
            indicators.sma5
          ) {
            this.smaSeries = this.candlestickChart.addLineSeries({
              color: "#2196F3",
              lineWidth: 2,
              title: "SMA(5)",
            });

            const smaData = indicators.sma5
              .filter(
                (point) => point.value !== null && point.value !== undefined
              )
              .map((point) => ({
                time: Number(point.time),
                value: parseFloat(point.value),
              }));

            this.smaSeries.setData(smaData);
          }

          // Add EMA(20) if requested
          if (
            ["ema20", "both", "all"].includes(this.currentIndicator) &&
            indicators.ema20
          ) {
            this.emaSeries = this.candlestickChart.addLineSeries({
              color: "#FF9800",
              lineWidth: 2,
              title: "EMA(20)",
            });

            const emaData = indicators.ema20
              .filter(
                (point) => point.value !== null && point.value !== undefined
              )
              .map((point) => ({
                time: Number(point.time),
                value: parseFloat(point.value),
              }));

            this.emaSeries.setData(emaData);
          }

          // Add Bollinger Bands if requested
          if (
            ["bollinger", "all"].includes(this.currentIndicator) &&
            indicators.bbUpper &&
            indicators.bbMiddle &&
            indicators.bbLower
          ) {
            this.addBollingerBands(indicators);
          }

          // Add Parabolic SAR if requested
          if (
            ["psar", "all"].includes(this.currentIndicator) &&
            indicators.psar
          ) {
            this.addParabolicSAR(indicators.psar);
          }

          // Add RSI if requested
          if (
            ["rsi", "all"].includes(this.currentIndicator) &&
            indicators.rsi
          ) {
            this.addRSISeries(indicators.rsi);
          }

          // Add Stochastic Oscillator if requested
          if (
            ["stochastic", "all"].includes(this.currentIndicator) &&
            indicators.stochK &&
            indicators.stochD
          ) {
            this.addStochasticSeries(indicators.stochK, indicators.stochD);
          }

          // Add Stochastic RSI if requested
          if (
            ["stochrsi", "all"].includes(this.currentIndicator) &&
            indicators.stochRSI
          ) {
            this.addStochasticRSISeries(indicators.stochRSI);
          }

          // Add MACD if requested
          if (
            ["macd", "all"].includes(this.currentIndicator) &&
            indicators.macdLine &&
            indicators.macdSignal &&
            indicators.macdHistogram
          ) {
            this.addMACDSeries(indicators);
          }
        }

        addRSISeries(rsiData) {
          // RSI line series
          this.rsiSeries = this.rsiChart.addLineSeries({
            color: "#9c27b0",
            lineWidth: 2,
            title: "RSI(14)",
          });

          // RSI reference lines
          this.rsiOverboughtLine = this.rsiChart.addLineSeries({
            color: "#f44336",
            lineWidth: 1,
            lineStyle: LightweightCharts.LineStyle.Dashed,
            title: "Overbought (70)",
          });

          this.rsiOversoldLine = this.rsiChart.addLineSeries({
            color: "#4caf50",
            lineWidth: 1,
            lineStyle: LightweightCharts.LineStyle.Dashed,
            title: "Oversold (30)",
          });

          // Prepare RSI data
          const processedRsiData = rsiData
            .filter(
              (point) => point.value !== null && point.value !== undefined
            )
            .map((point) => ({
              time: Number(point.time),
              value: parseFloat(point.value),
            }));

          // Create reference line data
          const referenceData70 = processedRsiData.map((point) => ({
            time: point.time,
            value: 70,
          }));

          const referenceData30 = processedRsiData.map((point) => ({
            time: point.time,
            value: 30,
          }));

          // Set data
          this.rsiSeries.setData(processedRsiData);
          this.rsiOverboughtLine.setData(referenceData70);
          this.rsiOversoldLine.setData(referenceData30);
        }

        clearIndicators() {
          // Remove SMA/EMA from candlestick chart
          if (this.smaSeries) {
            this.candlestickChart.removeSeries(this.smaSeries);
            this.smaSeries = null;
          }
          if (this.emaSeries) {
            this.candlestickChart.removeSeries(this.emaSeries);
            this.emaSeries = null;
          }

          // Remove Bollinger Bands
          if (this.bbUpperSeries) {
            this.candlestickChart.removeSeries(this.bbUpperSeries);
            this.bbUpperSeries = null;
          }
          if (this.bbMiddleSeries) {
            this.candlestickChart.removeSeries(this.bbMiddleSeries);
            this.bbMiddleSeries = null;
          }
          if (this.bbLowerSeries) {
            this.candlestickChart.removeSeries(this.bbLowerSeries);
            this.bbLowerSeries = null;
          }

          // Remove Parabolic SAR
          if (this.psarSeries) {
            this.candlestickChart.removeSeries(this.psarSeries);
            this.psarSeries = null;
          }

          // Remove RSI series
          if (this.rsiSeries) {
            this.rsiChart.removeSeries(this.rsiSeries);
            this.rsiSeries = null;
          }
          if (this.rsiOverboughtLine) {
            this.rsiChart.removeSeries(this.rsiOverboughtLine);
            this.rsiOverboughtLine = null;
          }
          if (this.rsiOversoldLine) {
            this.rsiChart.removeSeries(this.rsiOversoldLine);
            this.rsiOversoldLine = null;
          }

          // Remove Stochastic Oscillator
          if (this.stochKSeries) {
            this.rsiChart.removeSeries(this.stochKSeries);
            this.stochKSeries = null;
          }
          if (this.stochDSeries) {
            this.rsiChart.removeSeries(this.stochDSeries);
            this.stochDSeries = null;
          }
          if (this.stochOverboughtLine) {
            this.rsiChart.removeSeries(this.stochOverboughtLine);
            this.stochOverboughtLine = null;
          }
          if (this.stochOversoldLine) {
            this.rsiChart.removeSeries(this.stochOversoldLine);
            this.stochOversoldLine = null;
          }

          // Remove Stochastic RSI
          if (this.stochRSISeries) {
            this.rsiChart.removeSeries(this.stochRSISeries);
            this.stochRSISeries = null;
          }
          if (this.stochRSIOverboughtLine) {
            this.rsiChart.removeSeries(this.stochRSIOverboughtLine);
            this.stochRSIOverboughtLine = null;
          }
          if (this.stochRSIOversoldLine) {
            this.rsiChart.removeSeries(this.stochRSIOversoldLine);
            this.stochRSIOversoldLine = null;
          }

          // Remove MACD
          if (this.macdLineSeries) {
            this.rsiChart.removeSeries(this.macdLineSeries);
            this.macdLineSeries = null;
          }
          if (this.macdSignalSeries) {
            this.rsiChart.removeSeries(this.macdSignalSeries);
            this.macdSignalSeries = null;
          }
          if (this.macdHistogramSeries) {
            this.rsiChart.removeSeries(this.macdHistogramSeries);
            this.macdHistogramSeries = null;
          }
          if (this.macdZeroLine) {
            this.rsiChart.removeSeries(this.macdZeroLine);
            this.macdZeroLine = null;
          }
        }

        isRSIVisible() {
          return ["rsi", "stochastic", "stochrsi", "macd", "all"].includes(
            this.currentIndicator
          );
        }

        toggleRSIChart() {
          const rsiContainer = document.getElementById("rsi-chart");
          if (this.isRSIVisible()) {
            rsiContainer.style.display = "block";
          } else {
            rsiContainer.style.display = "none";
          }
        }

        connectWebSocket() {
          if (this.websocket) return;

          const protocol =
            window.location.protocol === "https:" ? "wss:" : "ws:";
          const wsUrl = `${protocol}//${window.location.host}/ws?timeframe=${this.currentTimeframe}`;

          this.websocket = new WebSocket(wsUrl);

          this.websocket.onopen = () => {
            console.log(`üì° WebSocket connected for ${this.currentTimeframe}`);
            this.updateStatus("Connected", true);
            this.reconnectAttempts = 0;
          };

          this.websocket.onmessage = (event) => {
            try {
              const data = JSON.parse(event.data);
              if (data.type === "connected") return; // Skip connection messages

              this.updateRealtime(data);
            } catch (error) {
              console.error("Error parsing WebSocket message:", error);
            }
          };

          this.websocket.onclose = () => {
            console.log(
              `üì° WebSocket disconnected from ${this.currentTimeframe}`
            );
            this.updateStatus("Disconnected", false);
            this.websocket = null;

            // Auto-reconnect with exponential backoff
            if (this.reconnectAttempts < this.maxReconnectAttempts) {
              const delay = Math.min(
                3000 * Math.pow(2, this.reconnectAttempts),
                30000
              );
              this.reconnectAttempts++;

              setTimeout(() => {
                if (!this.websocket) {
                  console.log(
                    `üîÑ Reconnecting WebSocket (attempt ${this.reconnectAttempts})...`
                  );
                  this.connectWebSocket();
                }
              }, delay);
            }
          };

          this.websocket.onerror = (error) => {
            console.error("WebSocket error:", error);
            this.updateStatus("Error", false);
          };
        }

        // TradingView-like realtime updates
        updateRealtime(data) {
          if (!data || !this.candleData.length || data.type === "connected")
            return;

          // Update global price tracking
          if (data.globalLastPrice) {
            this.lastPrice = data.globalLastPrice;
            this.updateLastPriceLine();
          }

          const newCandle = {
            time: Number(data.time),
            open: parseFloat(data.open),
            high: parseFloat(data.high),
            low: parseFloat(data.low),
            close: parseFloat(data.close),
          };

          const lastCandle = this.candleData[this.candleData.length - 1];

          // Format Jakarta time for logging
          const jakartaTime = new Date(newCandle.time * 1000).toLocaleString(
            "id-ID",
            {
              timeZone: "Asia/Jakarta",
              day: "2-digit",
              month: "2-digit",
              year: "numeric",
              hour: "2-digit",
              minute: "2-digit",
            }
          );

          // TradingView-like behavior: running candles
          if (newCandle.time === lastCandle.time) {
            // Update existing running candle
            console.log(
              `üîÑ Frontend - Updating running candle at ${newCandle.time} (${jakartaTime} WIB)`
            );

            // Update in-place
            this.candleData[this.candleData.length - 1] = newCandle;

            // Update chart with running candle
            this.candleSeries.update(newCandle);

            // Update last price
            this.lastPrice = newCandle.close;
            this.updateLastPriceLine();
          } else if (newCandle.time > lastCandle.time) {
            // New candle period started
            console.log(
              `‚ûï Frontend - New candle period started at ${newCandle.time} (${jakartaTime} WIB)`
            );
            this.candleData.push(newCandle);
            this.candleSeries.update(newCandle);

            // Update last price
            this.lastPrice = newCandle.close;
            this.updateLastPriceLine();

            // Keep array size reasonable for performance
            if (this.candleData.length > 1000) {
              this.candleData = this.candleData.slice(-1000);
              // If array is trimmed, reload entire data to chart
              this.candleSeries.setData(this.candleData);
            }

            // Auto-scroll for intraday timeframes
            if (["1m", "5m", "1h"].includes(this.currentTimeframe)) {
              setTimeout(() => {
                this.candlestickChart.timeScale().scrollToRealTime();
              }, 100);
            }
          } else {
            console.warn(
              `‚ö†Ô∏è Frontend - Received old candle (${newCandle.time}) vs current (${lastCandle.time})`
            );
          }

          // Update status with last price info
          this.updateStatus(
            `Connected - $${this.lastPrice?.toFixed(2) || "N/A"}`,
            true
          );
        }

        closeWebSocket() {
          if (this.websocket) {
            this.websocket.close();
            this.websocket = null;
            this.reconnectAttempts = 0;
          }
        }

        showLoading(text = "Loading...", subtext = "") {
          const overlay = document.getElementById("loading-overlay");
          const textEl = document.getElementById("loading-text");
          const subtextEl = document.getElementById("loading-subtext");

          textEl.textContent = text;
          subtextEl.textContent = subtext;
          overlay.classList.remove("hidden");
        }

        hideLoading() {
          const overlay = document.getElementById("loading-overlay");
          overlay.classList.add("hidden");
        }

        showError(message) {
          this.hideLoading();
          console.error(message);
          // Could add error toast here
        }

        updateStatus(text, connected) {
          const statusText = document.getElementById("status-text");
          const statusDot = document.getElementById("status-dot");

          statusText.textContent = text;
          statusDot.classList.toggle("disconnected", !connected);
        }

        // Method untuk menambahkan Bollinger Bands
        addBollingerBands(indicators) {
          // Upper Band
          this.bbUpperSeries = this.candlestickChart.addLineSeries({
            color: "#f44336",
            lineWidth: 1,
            title: "BB Upper",
          });

          // Middle Band (SMA)
          this.bbMiddleSeries = this.candlestickChart.addLineSeries({
            color: "#2196F3",
            lineWidth: 2,
            title: "BB Middle",
          });

          // Lower Band
          this.bbLowerSeries = this.candlestickChart.addLineSeries({
            color: "#4caf50",
            lineWidth: 1,
            title: "BB Lower",
          });

          // Process data untuk setiap band
          const upperData = indicators.bbUpper
            .filter(
              (point) => point.value !== null && point.value !== undefined
            )
            .map((point) => ({
              time: Number(point.time),
              value: parseFloat(point.value),
            }));

          const middleData = indicators.bbMiddle
            .filter(
              (point) => point.value !== null && point.value !== undefined
            )
            .map((point) => ({
              time: Number(point.time),
              value: parseFloat(point.value),
            }));

          const lowerData = indicators.bbLower
            .filter(
              (point) => point.value !== null && point.value !== undefined
            )
            .map((point) => ({
              time: Number(point.time),
              value: parseFloat(point.value),
            }));

          // Set data untuk semua band
          this.bbUpperSeries.setData(upperData);
          this.bbMiddleSeries.setData(middleData);
          this.bbLowerSeries.setData(lowerData);
        }

        // Method untuk menambahkan Parabolic SAR
        addParabolicSAR(psarData) {
          this.psarSeries = this.candlestickChart.addLineSeries({
            color: "#ff9800",
            lineWidth: 1,
            lineStyle: LightweightCharts.LineStyle.Dotted,
            title: "Parabolic SAR",
            crosshairMarkerVisible: true,
          });

          const processedData = psarData
            .filter(
              (point) => point.value !== null && point.value !== undefined
            )
            .map((point) => ({
              time: Number(point.time),
              value: parseFloat(point.value),
            }));

          this.psarSeries.setData(processedData);
        }

        // Method untuk menambahkan Stochastic Oscillator
        addStochasticSeries(stochKData, stochDData) {
          // %K line
          this.stochKSeries = this.rsiChart.addLineSeries({
            color: "#2196F3",
            lineWidth: 2,
            title: "Stoch %K",
          });

          // %D line
          this.stochDSeries = this.rsiChart.addLineSeries({
            color: "#ff9800",
            lineWidth: 2,
            title: "Stoch %D",
          });

          // Reference lines untuk overbought/oversold
          this.stochOverboughtLine = this.rsiChart.addLineSeries({
            color: "#f44336",
            lineWidth: 1,
            lineStyle: LightweightCharts.LineStyle.Dashed,
            title: "Overbought (80)",
          });

          this.stochOversoldLine = this.rsiChart.addLineSeries({
            color: "#4caf50",
            lineWidth: 1,
            lineStyle: LightweightCharts.LineStyle.Dashed,
            title: "Oversold (20)",
          });

          // Process data
          const kData = stochKData
            .filter(
              (point) => point.value !== null && point.value !== undefined
            )
            .map((point) => ({
              time: Number(point.time),
              value: parseFloat(point.value),
            }));

          const dData = stochDData
            .filter(
              (point) => point.value !== null && point.value !== undefined
            )
            .map((point) => ({
              time: Number(point.time),
              value: parseFloat(point.value),
            }));

          // Create reference lines data
          const overboughtData = kData.map((point) => ({
            time: point.time,
            value: 80,
          }));

          const oversoldData = kData.map((point) => ({
            time: point.time,
            value: 20,
          }));

          // Set data
          this.stochKSeries.setData(kData);
          this.stochDSeries.setData(dData);
          this.stochOverboughtLine.setData(overboughtData);
          this.stochOversoldLine.setData(oversoldData);
        }

        // Method untuk menambahkan Stochastic RSI
        addStochasticRSISeries(stochRSIData) {
          this.stochRSISeries = this.rsiChart.addLineSeries({
            color: "#9c27b0",
            lineWidth: 2,
            title: "Stochastic RSI",
          });

          // Reference lines
          this.stochRSIOverboughtLine = this.rsiChart.addLineSeries({
            color: "#f44336",
            lineWidth: 1,
            lineStyle: LightweightCharts.LineStyle.Dashed,
            title: "Overbought (80)",
          });

          this.stochRSIOversoldLine = this.rsiChart.addLineSeries({
            color: "#4caf50",
            lineWidth: 1,
            lineStyle: LightweightCharts.LineStyle.Dashed,
            title: "Oversold (20)",
          });

          // Process data
          const processedData = stochRSIData
            .filter(
              (point) => point.value !== null && point.value !== undefined
            )
            .map((point) => ({
              time: Number(point.time),
              value: parseFloat(point.value),
            }));

          // Reference lines data
          const overboughtData = processedData.map((point) => ({
            time: point.time,
            value: 80,
          }));

          const oversoldData = processedData.map((point) => ({
            time: point.time,
            value: 20,
          }));

          // Set data
          this.stochRSISeries.setData(processedData);
          this.stochRSIOverboughtLine.setData(overboughtData);
          this.stochRSIOversoldLine.setData(oversoldData);
        }

        // Method untuk menambahkan MACD
        addMACDSeries(indicators) {
          // MACD Line
          this.macdLineSeries = this.rsiChart.addLineSeries({
            color: "#2196F3",
            lineWidth: 2,
            title: "MACD",
          });

          // Signal Line
          this.macdSignalSeries = this.rsiChart.addLineSeries({
            color: "#ff9800",
            lineWidth: 2,
            title: "Signal",
          });

          // Histogram - menggunakan area series untuk visualisasi yang lebih baik
          this.macdHistogramSeries = this.rsiChart.addHistogramSeries({
            color: "#9c27b0",
            title: "Histogram",
          });

          // Zero line
          this.macdZeroLine = this.rsiChart.addLineSeries({
            color: "#666666",
            lineWidth: 1,
            lineStyle: LightweightCharts.LineStyle.Dashed,
            title: "Zero Line",
          });

          // Process data
          const macdData = indicators.macdLine
            .filter(
              (point) => point.value !== null && point.value !== undefined
            )
            .map((point) => ({
              time: Number(point.time),
              value: parseFloat(point.value),
            }));

          const signalData = indicators.macdSignal
            .filter(
              (point) => point.value !== null && point.value !== undefined
            )
            .map((point) => ({
              time: Number(point.time),
              value: parseFloat(point.value),
            }));

          const histogramData = indicators.macdHistogram
            .filter(
              (point) => point.value !== null && point.value !== undefined
            )
            .map((point) => ({
              time: Number(point.time),
              value: parseFloat(point.value),
              color: parseFloat(point.value) >= 0 ? "#26a69a" : "#ef5350",
            }));

          // Zero line data
          const zeroLineData = macdData.map((point) => ({
            time: point.time,
            value: 0,
          }));

          // Set data
          this.macdLineSeries.setData(macdData);
          this.macdSignalSeries.setData(signalData);
          this.macdHistogramSeries.setData(histogramData);
          this.macdZeroLine.setData(zeroLineData);
        }
      }

      // Initialize the chart when page loads
      document.addEventListener("DOMContentLoaded", () => {
        new CryptoChart();
      });
    </script>
  </body>
</html>
